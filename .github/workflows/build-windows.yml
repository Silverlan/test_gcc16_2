name: Check Windows Build
on:
  push:

env:
  # See https://github.com/git-lfs/git-lfs/issues/5749
  GIT_CLONE_PROTECTION_ACTIVE: 'false'

jobs:
  build:
    name: Build - ${{ matrix.config.os }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
          - os: windows-latest
            name: "Windows x64 MSVC"
            artifact: "Windows-MSVC.tar.xz"
            build_type: "RelWithDebInfo"
            environment_script: "C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Auxiliary/Build/vcvars64.bat"
            cc: "cl"
            cxx: "cl"
            archiver: "7z a"
            generators: "Visual Studio 17 2022"
            build_dir: 'build'
    steps:
      - name: Windows disk diagnostics — multi-depth (pwsh, tolerant, fixed)
        shell: pwsh
        run: |
          # tolerant diagnostics: aggregate sizes by multiple depths in one pass
          $ErrorActionPreference = 'Continue'

          $Base = 'C:\'
          $MaxDepth = 4    # how many directory levels to aggregate (1 = top-level children, 2 = grandchildren, ...)
          $TopN = 30       # how many top entries to display per depth

          Write-Output "=== Multi-depth Windows disk diagnostics ==="
          Write-Output "Time: $(Get-Date -AsUTC -Format 'yyyy-MM-dd HH:mm:ssZ')"
          Write-Output "Base: $Base  MaxDepth: $MaxDepth  TopN: $TopN"
          Write-Output ""

          try {
            # normalize base path (ensure trailing backslash)
            $baseItem = Get-Item -LiteralPath $Base -ErrorAction SilentlyContinue
            if ($null -ne $baseItem) {
              $baseNorm = $baseItem.FullName.TrimEnd('\') + '\'
            } else {
              $baseNorm = (Resolve-Path -LiteralPath $Base -ErrorAction SilentlyContinue).Path.TrimEnd('\') + '\'
            }
          } catch {
            $baseNorm = $Base.TrimEnd('\') + '\'
          }

          Write-Output "Normalized base path: $baseNorm"
          Write-Output ""

          # Drive summary
          try {
            Write-Output "--- Drive summary (Get-Volume) ---"
            Get-Volume -DriveLetter ($baseNorm.Substring(0,1)) -ErrorAction SilentlyContinue |
              Select-Object DriveLetter, @{N='Label';E={$_.FileSystemLabel}}, @{N='SizeGB';E={[math]::Round($_.Size/1GB,2)}}, @{N='FreeGB';E={[math]::Round($_.SizeRemaining/1GB,2)}}, @{N='PctFree';E={ if ($_.Size -gt 0) {[math]::Round($_.SizeRemaining/$_.Size*100,1)} else {'N/A'} }} |
              Format-Table -AutoSize
          } catch {
            Write-Warning "Get-Volume failed: $($_.Exception.Message)"
          }
          Write-Output ""

          # prepare aggregation tables: depth -> hashtable(path -> sizeBytes)
          $agg = @{}
          for ($d = 1; $d -le $MaxDepth; $d++) { $agg[$d] = @{} }

          Write-Output "Scanning files (this may take a while for large images). Streaming aggregation..."
          Write-Output ""

          try {
            # Stream all files under base once, aggregate into depth buckets.
            # Use -File to avoid enumerating directories as items here.
            Get-ChildItem -LiteralPath $baseNorm -Force -Recurse -ErrorAction SilentlyContinue -File |
              ForEach-Object -Process {
                $f = $_
                # ensure file is on same normalized base (defensive)
                if (-not $f.FullName.StartsWith($baseNorm, [System.StringComparison]::OrdinalIgnoreCase)) { return }

                $rel = $f.FullName.Substring($baseNorm.Length).TrimStart('\')
                if ($rel -eq '') { return }   # skip weird root-level matching
                $parts = $rel -split '\\'
                $count = $parts.Count

                # accumulate file size for each ancestor up to MaxDepth
                for ($d = 1; $d -le $MaxDepth; $d++) {
                  if ($count -lt $d) { break }
                  $sub = ($parts[0..($d-1)] -join '\')
                  $key = ($baseNorm.TrimEnd('\') + '\' + $sub).TrimEnd('\')
                  if (-not $agg[$d].ContainsKey($key)) { $agg[$d][$key] = 0 }
                  $agg[$d][$key] += [int64]$f.Length
                }
              }
          } catch {
            Write-Warning "File scan failed or was partially interrupted: $($_.Exception.Message)"
          }

          Write-Output "`n--- Aggregated top directories by depth ---`n"

          for ($d = 1; $d -le $MaxDepth; $d++) {
            Write-Output ">>> Top $TopN directories at depth ${d} (aggregated size of files beneath each):"
            try {
              $pairs = $agg[$d].GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $TopN
              if ($pairs.Count -eq 0) {
                Write-Output "  (no entries found at depth ${d} — maybe permission errors or empty)"
              } else {
                $pairs | ForEach-Object {
                  [PSCustomObject]@{
                    SizeGB = [math]::Round($_.Value / 1GB, 3)
                    SizeMB = [math]::Round($_.Value / 1MB, 1)
                    Path   = $_.Key
                  }
                } | Format-Table SizeGB, SizeMB, Path -AutoSize
              }
            } catch {
              Write-Warning "Aggregation/printing failed for depth ${d}: $($_.Exception.Message)"
            }
            Write-Output ""
          }

          Write-Output "--- Top large files on $baseNorm (>=100MB) ---"
          try {
            Get-ChildItem -LiteralPath $baseNorm -Force -Recurse -ErrorAction SilentlyContinue -File |
              Where-Object { $_.Length -ge 100MB } |
              Select-Object @{N='SizeMB';E={[math]::Round($_.Length/1MB,2)}}, FullName |
              Sort-Object SizeMB -Descending |
              Select-Object -First 100 |
              Format-Table SizeMB, FullName -AutoSize
          } catch {
            Write-Warning "Large-file scan failed: $($_.Exception.Message)"
          }

          Write-Output ""
          Write-Output "Note: aggregation is derived from file sizes only (folders themselves have negligible intrinsic size)."
          Write-Output "If you need deeper MaxDepth (or faster scanning), reduce scanning scope (e.g. target C:\Program Files) or increase runner resources."
          Write-Output ""
          Write-Output "=== END ==="

          # Always succeed — diagnostics only
          exit 0
