name: Check Windows Build
on:
  push:

env:
  # See https://github.com/git-lfs/git-lfs/issues/5749
  GIT_CLONE_PROTECTION_ACTIVE: 'false'

jobs:
  build:
    name: Build - ${{ matrix.config.os }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
          - os: windows-latest
            name: "Windows x64 MSVC"
            artifact: "Windows-MSVC.tar.xz"
            build_type: "RelWithDebInfo"
            environment_script: "C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Auxiliary/Build/vcvars64.bat"
            cc: "cl"
            cxx: "cl"
            archiver: "7z a"
            generators: "Visual Studio 17 2022"
            build_dir: 'build'
    steps:
      - name: Windows disk diagnostics (pwsh — tolerant, never fail)
        shell: pwsh
        run: |
          # tolerate failures and never return non-zero to GH Actions
          $ErrorActionPreference = 'Continue'

          Write-Output "=== Windows disk diagnostics (Get-Volume + top dirs + large files) ==="
          Write-Output "Time: $(Get-Date -AsUTC -Format 'yyyy-MM-dd HH:mm:ssZ')"

          try {
            Write-Output "`n--- Drive summary (Get-Volume) ---"
            Get-Volume -DriveLetter C -ErrorAction SilentlyContinue |
              Select-Object DriveLetter, FileSystemLabel,
                @{N='SizeGB';E={[math]::Round($_.Size/1GB,2)}},
                @{N='FreeGB';E={[math]::Round($_.SizeRemaining/1GB,2)}},
                @{N='PctFree';E={ if ($_.Size -gt 0) {[math]::Round($_.SizeRemaining/$_.Size*100,1)} else {'N/A'} }} |
              Format-Table -AutoSize
          } catch {
            Write-Warning "Get-Volume failed: $($_.Exception.Message)"
          }

          try {
            Write-Output "`n--- Shadow storage (vssadmin) ---"
            vssadmin list shadowstorage 2>&1 | ForEach-Object { Write-Output $_ }
          } catch {
            Write-Warning "vssadmin failed: $($_.Exception.Message)"
          }

          try {
            Write-Output "`n--- Installed shadow copies (vssadmin list shadows) ---"
            vssadmin list shadows 2>&1 | ForEach-Object { Write-Output $_ }
          } catch {
            Write-Warning "vssadmin list shadows failed: $($_.Exception.Message)"
          }

          try {
            Write-Output "`n--- pagefile & hiberfile sizes ---"
            Get-Item -Path C:\pagefile.sys,C:\hiberfil.sys -ErrorAction SilentlyContinue |
              Select-Object Name, @{N='SizeGB';E={ if ($_.Length) {[math]::Round($_.Length/1GB,2)} else {'N/A'} }} |
              Format-Table -AutoSize
          } catch {
            Write-Warning "pagefile/hiberfile check failed: $($_.Exception.Message)"
          }

          try {
            Write-Output "`n--- System Volume Information summary (may require admin) ---"
            $s = Get-ChildItem -LiteralPath 'C:\System Volume Information' -Force -Recurse -ErrorAction SilentlyContinue |
                  Measure-Object -Property Length -Sum
            [PSCustomObject]@{ Path='C:\System Volume Information'; SizeGB = [math]::Round(($s.Sum/1GB),3) } | Format-Table -AutoSize
          } catch {
            Write-Warning "SVI check failed: $($_.Exception.Message)"
          }

          try {
            Write-Output "`n--- Top directories under C:\\ (one level) by aggregated size ---"
            # iterate top-level directories and sum size; -ErrorAction SilentlyContinue to avoid "access denied" stopping us
            Get-ChildItem -Path C:\ -Force -Directory -ErrorAction SilentlyContinue |
              ForEach-Object {
                $p = $_.FullName
                $sum = 0
                try {
                  $sum = (Get-ChildItem -Path $p -Recurse -Force -File -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
                } catch {
                  Write-Warning "Failed scanning $p : $($_.Exception.Message)"
                }
                [PSCustomObject]@{ Path = $p; SizeBytes = $sum; SizeGB = [math]::Round(($sum/1GB),3) }
              } |
              Sort-Object SizeBytes -Descending | Select-Object -First 40 |
              Format-Table SizeGB, Path -AutoSize
          } catch {
            Write-Warning "Top directories scan failed: $($_.Exception.Message)"
          }

          try {
            Write-Output "`n--- Top large files on C: (>=100MB) ---"
            # Stream results to avoid huge memory pressure; suppress non-fatal errors
            Get-ChildItem -Path C:\ -Force -Recurse -ErrorAction SilentlyContinue -File |
              Where-Object { $_.Length -ge 100MB } |
              Select-Object FullName, @{N='SizeMB';E={[math]::Round($_.Length/1MB,2)}} |
              Sort-Object SizeMB -Descending |
              Select-Object -First 100 |
              Format-Table SizeMB, FullName -AutoSize
          } catch {
            Write-Warning "Large-file scan failed: $($_.Exception.Message)"
          }

          Write-Output "`nNote: this diagnostic step is intentionally tolerant — it will not fail the job even if parts of the scan hit permission errors."
          Write-Output "If you want the step to fail on errors, remove the try/catch blocks and change ErrorAction behavior."

          # ALWAYS exit success so the workflow doesn't fail just for diagnostics
          exit 0
