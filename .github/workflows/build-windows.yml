name: Check Windows Build
on:
  push:

env:
  # See https://github.com/git-lfs/git-lfs/issues/5749
  GIT_CLONE_PROTECTION_ACTIVE: 'false'

jobs:
  build:
    name: Build - ${{ matrix.config.os }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
          - os: windows-latest
            name: "Windows x64 MSVC"
            artifact: "Windows-MSVC.tar.xz"
            build_type: "RelWithDebInfo"
            environment_script: "C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Auxiliary/Build/vcvars64.bat"
            cc: "cl"
            cxx: "cl"
            archiver: "7z a"
            generators: "Visual Studio 17 2022"
            build_dir: 'build'
    steps:
      - name: Print Disk Space (Windows)
        shell: pwsh
        run: |
          # PowerShell disk-report (rough equivalent of the bash version)
          # Usage (optional): pass arguments after the script block, e.g.
          #   --path C:\ --top 50 --depth 5
          $PathToCheck = 'C:\'
          $TopN = 25
          $Depth = 20

          # parse args passed to this pwsh run block (if any)
          for ($i = 0; $i -lt $args.Count; ) {
            switch ($args[$i]) {
              '--path' { $PathToCheck = $args[$i + 1]; $i += 2; break }
              '--top'  { $TopN = [int]$args[$i + 1]; $i += 2; break }
              '--depth'{ $Depth = [int]$args[$i + 1]; $i += 2; break }
              '--help' {
                Write-Output "Reduced disk-report (report-only)"
                Write-Output "Usage: pass optional flags after the step:"
                Write-Output "  --path PATH   (default C:\)"
                Write-Output "  --top  N      (default 25)"
                Write-Output "  --depth D     (max directory depth to report, default 20)"
                exit 0
              }
              default {
                Write-Warning "Unknown arg: $($args[$i])"
                exit 2
              }
            }
          }

          function Timestamp { (Get-Date).ToUniversalTime().ToString('yyyy-MM-dd HH:mm:ssZ') }

          function Format-Size([Nullable[long]]$bytes) {
            if ($null -eq $bytes) { return '-' }
            $b = [double]$bytes
            switch ($b) {
              {$_ -ge 1TB} { return "{0:N2} TB" -f ($b / 1TB) }
              {$_ -ge 1GB} { return "{0:N2} GB" -f ($b / 1GB) }
              {$_ -ge 1MB} { return "{0:N2} MB" -f ($b / 1MB) }
              {$_ -ge 1KB} { return "{0:N2} KB" -f ($b / 1KB) }
              default { return "$bytes B" }
            }
          }

          # Normalize path
          try {
            $resolved = (Resolve-Path -Path $PathToCheck -ErrorAction Stop).Path
          } catch {
            Write-Warning "Could not resolve path '$PathToCheck'. Falling back to C:\"
            $resolved = 'C:\'
          }
          $PathToCheck = $resolved.TrimEnd('\')

          Write-Output ""
          Write-Output "=== Disk console report (NO FILES) ==="
          Write-Output "Time: $(Timestamp)"
          Write-Output "Inspecting: $PathToCheck  (top $TopN, scan max-depth=$Depth)"
          Write-Output ""

          # Show drive / filesystem usage for the path
          $root = [System.IO.Path]::GetPathRoot($PathToCheck)         # e.g. "C:\"
          $deviceId = $root.TrimEnd('\')                             # e.g. "C:"
          $disk = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='$deviceId'" -ErrorAction SilentlyContinue

          if ($null -ne $disk) {
            $size = [int64]$disk.Size
            $free = [int64]$disk.FreeSpace
            $used = $size - $free
            $pctUsed = if ($size -gt 0) { "{0:N1}" -f (100.0 * $used / $size) } else { "?" }
            Write-Output ("Drive {0}  Size: {1}  Used: {2} ({3}%)  Free: {4}" -f $deviceId,
                          (Format-Size $size), (Format-Size $used), $pctUsed, (Format-Size $free))
          } else {
            # fallback: show PSDrive info
            Get-PSDrive -PSProvider FileSystem | Format-Table Name, Root, Used, Free, @{Label='Size';Expression={ if ($_.Used -and $_.Free) {Format-Size(($_.Used + $_.Free))} else {'-'}}} -AutoSize
          }

          Write-Output ""
          Write-Output ("--- Top $TopN directories (aggregated size, depth <= $Depth) under $PathToCheck ---")

          # function to compute depth difference (# of separators relative to base)
          function Get-RelativeDepth($base, $full) {
            $b = $base.TrimEnd('\') -split '\\' | Where-Object { $_ -ne '' }
            $f = $full.TrimEnd('\') -split '\\' | Where-Object { $_ -ne '' }
            return ($f.Count - $b.Count)
          }

          # Gather directories up to requested depth (including base)
          try {
            $baseDepth = (Get-Item -LiteralPath $PathToCheck).FullName.TrimEnd('\') -split '\\' | Where-Object { $_ -ne '' } | Measure-Object | Select-Object -ExpandProperty Count
          } catch {
            $baseDepth = ($PathToCheck.TrimEnd('\') -split '\\' | Where-Object { $_ -ne '' }).Count
          }

          # Include the base directory itself first
          $dirList = @()
          $dirList += Get-Item -LiteralPath $PathToCheck -ErrorAction SilentlyContinue

          # Enumerate directories and filter by depth
          # Use -Recurse; in PowerShell 7 there is -Depth but we keep compatible logic.
          Write-Output "Scanning directories (this may take a while on large trees)..."
          $allDirs = Get-ChildItem -LiteralPath $PathToCheck -Directory -Recurse -ErrorAction SilentlyContinue
          foreach ($d in $allDirs) {
            $rd = Get-RelativeDepth $PathToCheck $d.FullName
            if ($rd -le $Depth) { $dirList += $d }
          }

          # Pre-enumerate all files once to speed repeated size calculations
          $allFiles = Get-ChildItem -LiteralPath $PathToCheck -File -Recurse -ErrorAction SilentlyContinue

          $dirSizes = foreach ($d in $dirList) {
            # sum sizes of files under this directory (including subdirs)
            $prefix = $d.FullName.TrimEnd('\')
            $sum = ($allFiles | Where-Object { $_.FullName.StartsWith($prefix, [System.StringComparison]::OrdinalIgnoreCase) } | Measure-Object -Property Length -Sum).Sum
            [PSCustomObject]@{ Path = $d.FullName; Size = [int64]$sum }
          }

          $dirSizes | Sort-Object Size -Descending | Select-Object -First $TopN |
            ForEach-Object { "{0,12}  {1}" -f (Format-Size $_.Size), $_.Path } | Write-Output

          Write-Output ""
          Write-Output ("--- Top $TopN files under $PathToCheck ---")
          try {
            Get-ChildItem -LiteralPath $PathToCheck -File -Recurse -ErrorAction SilentlyContinue |
              Sort-Object Length -Descending |
              Select-Object -First $TopN |
              ForEach-Object { "{0,12}  {1}" -f (Format-Size $_.Length), $_.FullName } |
              Write-Output
          } catch {
            Write-Warning "Failed scanning files for top-$TopN files: $_"
          }

          Write-Output ""
          Write-Output ("--- Top $TopN items (files + dirs) under $PathToCheck (aggregated dir sizes) ---")
          # Compose combined list: directories (with aggregated sizes) + files
          $topDirs = $dirSizes | Sort-Object Size -Descending | Select-Object -First $TopN
          $topFiles = Get-ChildItem -LiteralPath $PathToCheck -File -Recurse -ErrorAction SilentlyContinue |
                        Sort-Object Length -Descending | Select-Object -First $TopN |
                        ForEach-Object { [PSCustomObject]@{ Path = $_.FullName; Size = [int64]$_.Length } }

          $combined = @()
          $combined += $topDirs
          $combined += $topFiles
          $combined | Sort-Object Size -Descending | Select-Object -First $TopN |
            ForEach-Object { "{0,12}  {1}" -f (Format-Size $_.Size), $_.Path } |
            Write-Output

          Write-Output ""
          Write-Output ("Final drive usage for $PathToCheck:")
          if ($null -ne $disk) {
            Write-Output ("Drive {0}  Size: {1}  Used: {2}  Free: {3}" -f $deviceId, (Format-Size $size), (Format-Size $used), (Format-Size $free))
          } else {
            Get-PSDrive -PSProvider FileSystem | Format-Table Name, Root, @{Label='Size';Expression={ if ($_.Used -and $_.Free) {Format-Size(($_.Used + $_.Free))} else {'-'}}}, Used, Free -AutoSize
          }

          Write-Output ""
          Write-Output "=== END ==="

          # End of script
          